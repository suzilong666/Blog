# 响应式原理

# 概念

**响应式：**数据变化自动触发视图更新的机制。开发者只需修改数据，无需手动操作DOM。

## Vue 2 响应式原理

### 核心：Object.defineProperty

通过 Object.defineProperty 对数据对象的属性进行递归拦截，将其转换为 getter/setter。

- getter：收集依赖（记录哪些组件使用了该属性）
- setter：触发更新（通知依赖该属性的组件重新渲染）

### 三大核心模块

- **Observer**：遍历数据对象，使用 Object.defineProperty 为所有属性添加 getter/setter。
- **Dep（依赖收集器）**：每个响应式属性对应一个 Dep 实例，负责管理该属性的所有观察者（Watcher）。
- **Watcher（观察者）**：组件渲染、计算属性、侦听器都会创建 Watcher。当数据变化时，Dep 通知对应的 Watcher 执行更新。

### 工作流程

1. 初始化阶段：Vue 遍历 data 选项，通过 Observer 将属性转为响应式。
2. 编译阶段：解析模板，遇到使用数据的表达式时触发 getter。
3. 依赖收集：getter 中将当前正在渲染的 Watcher 收集进 Dep 的订阅列表中。
4. 派发更新：数据修改时触发 setter，Dep 通知所有订阅的 Watcher。
5. 视图更新：Watcher 调用更新函数，组件重新渲染。

**源码执行顺序**
```js
// new Vue() 执行流程
new Vue()
  → this._init()  // src/core/instance/init.js
    → initState()  // src/core/instance/state.js
      → initData()  // 初始化data
        → observe()  // 创建Observer实例
```

### 局限性

- 无法检测对象属性的添加/删除：需要使用 Vue.set 或 this.$set。
- 无法直接检测数组索引和长度的变化：Vue 重写了数组的 7 个变更方法（push、pop、shift、unshift、splice、sort、reverse）来实现响应式。
- 初始化时递归劫持：性能开销与对象嵌套深度成正比。
  
## 源码实现

### Observer 类的实现

```js
// src/core/observer/index.js
export class Observer {
  constructor(value) {
    this.value = value
    this.dep = new Dep()  // 数组专用的依赖管理器
    this.vmCount = 0
    
    // 将Observer实例挂载到对象上，防止重复处理
    def(value, '__ob__', this)
    
    if (Array.isArray(value)) {
      // 数组处理：重写原型链
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      // 遍历数组，将数组元素转为响应式
      this.observeArray(value)
    } else {
      // 对象处理：遍历属性定义响应式
      this.walk(value)
    }
  }
  
  // 遍历对象所有属性，转换为getter/setter
  walk(obj) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }
  
  // 观察数组中的每一项
  observeArray(items) {
    for (let i = 0; i < items.length; i++) {
      observe(items[i])
    }
  }
}
```

### defineReactive 核心函数

```js
// src/core/observer/index.js
export function defineReactive(obj, key, val, customSetter, shallow) {
  // 为每个属性创建一个Dep实例（依赖收集器）
  const dep = new Dep()
  
  // 获取属性原有的描述符
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }
  
  // 保存原有的getter/setter
  const getter = property && property.get
  const setter = property && property.set
  
  // 如果只传了obj和key，获取对应的值
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }
  
  // 递归处理子对象（深度观测）
  let childOb = !shallow && observe(val)
  
  // 核心：定义响应式属性
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      const value = getter ? getter.call(obj) : val
      
      // 依赖收集：当Dep.target有值时（当前正在计算的Watcher）
      if (Dep.target) {
        dep.depend()  // 让dep收集当前Watcher
        
        if (childOb) {
          // 子对象也要收集依赖（用于数组/对象添加属性的场景）
          childOb.dep.depend()
          
          // 如果是数组，特殊处理
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter(newVal) {
      const value = getter ? getter.call(obj) : val
      
      // 如果值没有变化，不触发更新
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      
      // 如果属性有setter，调用它
      if (getter && !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      
      // 对新值进行响应式处理
      childOb = !shallow && observe(newVal)
      
      // 核心：通知所有依赖，值已经改变
      dep.notify()
    }
  })
}
```

### Dep 依赖管理器

```js
// src/core/observer/dep.js
export default class Dep {
  static target: ?Watcher;  // 当前正在计算的Watcher（全局唯一）
  id: number;
  subs: Array<Watcher>;     // 存储所有订阅该属性的Watcher
  
  constructor() {
    this.id = uid++
    this.subs = []
  }
  
  // 添加依赖
  addSub(sub: Watcher) {
    this.subs.push(sub)
  }
  
  // 移除依赖
  removeSub(sub: Watcher) {
    remove(this.subs, sub)
  }
  
  // 依赖收集（让Watcher反向收集dep）
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this)  // Watcher添加当前dep
    }
  }
  
  // 通知更新
  notify() {
    const subs = this.subs.slice()
    // 不按id排序，保证Watcher执行顺序
    for (let i = 0; i < subs.length; i++) {
      subs[i].update()  // 调用Watcher的update方法
    }
  }
}

// 当前正在计算的Watcher，同一时刻只有一个
Dep.target = null
const targetStack = []

// 压栈（用于嵌套组件）
export function pushTarget(target: ?Watcher) {
  targetStack.push(target)
  Dep.target = target
}

export function popTarget() {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
```

### Watcher 观察者

```js
// src/core/observer/watcher.js
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deps: Array<Dep>;          // 当前Watcher收集的所有dep
  newDeps: Array<Dep>;        // 新一次的依赖
  depIds: SimpleSet;          // 去重的dep id集合
  newDepIds: SimpleSet;
  
  constructor(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm
    this.cb = cb
    this.id = ++uid
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    
    // 解析表达式（支持函数或表达式字符串）
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)  // 解析'a.b.c'形式的表达式
    }
    
    this.value = this.get()  // 立即求值，触发依赖收集
  }
  
  // 求值，触发依赖收集
  get() {
    // 将当前Watcher设置为Dep.target
    pushTarget(this)
    let value
    const vm = this.vm
    
    try {
      // 执行getter函数（如渲染函数），访问数据属性，触发getter进行依赖收集
      value = this.getter.call(vm, vm)
    } catch (e) {
      // 错误处理
    } finally {
      // 移除当前Watcher
      popTarget()
      // 清理不需要的依赖
      this.cleanupDeps()
    }
    
    return value
  }
  
  // 添加依赖（由Dep调用）
  addDep(dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      
      // 避免重复添加
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }
  
  // 清理依赖（用于优化，移除不再使用的依赖）
  cleanupDeps() {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    
    // 交换newDeps和deps
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }
  
  // 依赖变更时调用（由Dep通知）
  update() {
    if (this.lazy) {
      this.dirty = true  // 计算属性
    } else if (this.sync) {
      this.run()  // 同步执行
    } else {
      // 异步更新队列（重要优化）
      queueWatcher(this)
    }
  }
  
  // 实际执行更新
  run() {
    if (this.active) {
      const value = this.get()
      
      // 值变化时调用回调
      if (value !== this.value || isObject(value) || this.deep) {
        const oldValue = this.value
        this.value = value
        
        if (this.user) {
          // 用户Watcher，执行回调并捕获错误
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
}
```

### 数组的响应式处理

```js
// src/core/observer/array.js
// 数组原型方法重写
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]
  
  arrayMethods[method] = function mutator(...args) {
    // 执行原数组方法
    const result = original.apply(this, args)
    
    // 获取Observer实例
    const ob = this.__ob__
    
    // 获取新增的元素（可能需要对新增元素做响应式处理）
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    
    // 将新增元素转为响应式
    if (inserted) ob.observeArray(inserted)
    
    // 通知更新
    ob.dep.notify()
    
    return result
  }
})
```