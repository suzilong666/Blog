# 继承

在JavaScript中，继承是实现对象复用和构建对象层次结构的重要机制。JavaScript中的继承主要是基于原型的（prototype-based），而不是像传统面向对象语言（如Java）那样的基于类的继承。不过，ES6引入了class语法，使得继承的写法更接近传统语言，但本质上仍然是基于原型的。

## 实现继承的方式

### 原型链继承

通过将子类的原型设置为父类的实例来实现继承。

```js
function Parent(name) {
    this.name = name;
    this.colors = ['red', 'blue'];
}

Parent.prototype.sayName = function() {
    console.log(this.name);
};

function Child(age) {
    this.age = age;
}

// 原型链继承
Child.prototype = new Parent('parent');

const child1 = new Child(5);
child1.colors.push('green'); // 影响所有实例
console.log(child1.name); // 'parent'
```

**缺点：**

- 共享引用属性
- 无法向父类传参

### 构造函数继承

在子类构造函数中调用父类构造函数，使用call或apply方法改变this指向。

```js
function Parent(name) {
  this.name = name;
}

function Child(name, age) {
  Parent.call(this, name); // 继承父类实例属性
  this.age = age;
}

var child = new Child('Tom', 10);
console.log(child.name); // Tom
console.log(child.age); // 10
```

**优点：**

- 避免了引用类型属性被所有实例共享。
- 可以在子类构造函数中向父类构造函数传递参数。

**缺点：**

- 不能继承父类原型上的方法。

### 组合继承（最常用）

结合原型链继承和构造函数继承，是JavaScript中最常用的继承模式。

```js
function Parent(name) {
  this.name = name;
}

Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承实例属性
  this.age = age;
}

Child.prototype = new Parent(); // 继承父类原型
Child.prototype.constructor = Child; // 修复constructor指向

var child = new Child('Tom', 10);
child.sayName(); // Tom
```
**优点：**

- 既继承了父类的实例属性，又继承了父类原型上的方法。
- 可以传参，且每个实例有自己的属性，不会共享引用类型属性。

**缺点：**

- 调用了两次父类构造函数（一次在创建子类原型时，一次在子类构造函数内部），导致子类原型上有一份多余的父类实例属性。

### 原型式继承

使用一个函数来创建一个临时构造函数，将传入的对象作为这个构造函数的原型，然后返回这个临时构造函数的实例。

```js
function createObject(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

var parent = {
  name: 'parent',
  sayName: function() {
    console.log(this.name);
  }
};

var child = createObject(parent);
child.name = 'child';
child.sayName(); // child
```

ES5中规范化了原型式继承，使用Object.create()方法。

```js
var parent = {
  name: 'parent',
  sayName: function() {
    console.log(this.name);
  }
};

var child = Object.create(parent);
child.name = 'child';
child.sayName(); // child
```

适用于不需要单独创建构造函数，但仍然需要在对象间共享信息的场景。但是，引用类型的属性会被所有实例共享。

### 寄生式继承

在原型式继承的基础上，增强对象，然后返回这个对象。

```js
function createAnother(original) {
  var clone = Object.create(original); // 创建新对象
  clone.sayHi = function() { // 增强对象
    console.log('hi');
  };
  return clone;
}

var parent = {
  name: 'parent'
};

var child = createAnother(parent);
child.sayHi(); // hi
```

**缺点：**和构造函数继承一样，每次创建对象都会创建一遍方法，无法复用。

### 寄生组合式继承

这是最理想的继承方式，解决了组合继承调用两次父类构造函数的问题。

```js
function inheritPrototype(child, parent) {
  var prototype = Object.create(parent.prototype); // 创建父类原型的一个副本
  prototype.constructor = child; // 修复constructor
  child.prototype = prototype;
}

function Parent(name) {
  this.name = name;
}

Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

inheritPrototype(Child, Parent);

var child = new Child('Tom', 10);
child.sayName(); // Tom
```

**优点：**

- 只调用一次父类构造函数，避免在子类原型上创建不必要的属性。
- 原型链保持不变，能够正常使用instanceof和isPrototypeOf。

### ES6的class继承

ES6引入了class语法，使得继承更加清晰和容易。

```js
class Parent {
  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name); // 调用父类的constructor
    this.age = age;
  }

  // 可以添加子类自己的方法
}

let child = new Child('Tom', 10);
child.sayName(); // Tom
```

class只是一个语法糖，底层使用寄生组合式继承。

