# 闭包

[MDN链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Closures)

在JavaScript中，闭包（Closure）是一个重要且常用的概念。简单来说，闭包是指一个函数能够访问并记住其词法作用域，即使该函数在其词法作用域之外执行。

闭包的形成通常发生在嵌套函数中，内部函数引用了外部函数的变量，并且内部函数被返回或者在别处被使用，从而形成了闭包。

#### 一个简单闭包示例

```js
function foo() {
    var num = 1

    function bar() {
        console.log(num)
    }

    return bar
}

var bar = foo()
bar() // 打印：1
```

## 闭包的应用场景

1. 单例模式
2. 模拟私有属性
3. 柯里化
4. 防抖/节流
5. 事件处理

> 闭包的应用，大多数是在需要维护内部变量的场景下。

## 循环中的闭包问题

```js
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}
```
上面的打印会输出什么呢？结论是全都输出5。

**解决方案**

#### 使用IIFE（立即执行函数表达式）

```js
for (var i = 0; i < 5; i++) {
  (function(index) {
    setTimeout(function() {
      console.log(index); // 0,1,2,3,4
    }, 100);
  })(i);
}
```

#### 使用let（ES6+）

```js
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 0,1,2,3,4
  }, 100);
}
```

## 闭包的优缺点

**优点**
1. 数据封装：创建私有变量和方法
2. 状态保持：函数可以记住创建时的环境
3. 模块化：实现模块模式，避免全局污染
4. 函数柯里化：创建预先填充某些参数的函数

**缺点**
1. 内存消耗：闭包会保持对外部变量的引用，可能导致内存无法释放
2. 性能考虑：频繁创建闭包可能影响性能

## 最佳实践

1. 避免不必要的闭包
2. 及时释放引用
```js
let closure = createClosure();
// 使用完毕后
closure = null; // 帮助垃圾回收
```
3. 谨慎在循环中创建闭包