# 提升

JavaScript 中的 提升（Hoisting） 是指在代码执行之前，变量和函数声明会被移动到其作用域顶部的行为。这是一个重要的概念，理解它有助于避免常见的错误。

## 编译与执行

当JavaScript引擎执行代码时，它会经历两个主要阶段：编译阶段（或解析阶段）和执行阶段。

1. **编译阶段：**在这个阶段，引擎会解析整个代码，并创建执行上下文。在这个过程中，它会将所有变量和函数的声明添加到内存中（即所谓的“提升”），但不会执行赋值操作。对于函数声明，整个函数体也会被提升。而对于变量，只有声明本身被提升，赋值操作会留在原地，等待执行阶段。
2. **执行阶段：**在这个阶段，代码会逐行执行，赋值操作和函数调用都会在这一阶段进行。

因此，提升是发生在编译阶段，而不是执行阶段。这就是为什么我们可以在函数声明之前调用函数，因为函数声明在编译阶段就已经被放入内存中了。

但是，需要注意的是，虽然提升让我们能够在声明之前使用函数或变量，但这并不代表代码的实际位置发生了改变。提升是一个概念，帮助我们理解为什么代码会以这种方式运行。

另外，对于let和const，它们也存在提升，但是与var不同，它们被提升后不会被初始化为undefined，而是在声明之前处于“暂时性死区”（TDZ），访问它们会抛出错误。这也是编译阶段和处理方式的不同。

值得注意的是，每个作用域都会进行提升操作。

## 变量提升

var 的变量提升

```js
console.log(a); // undefined，而不是报错
var a = 5;
console.log(a); // 5
```

实际上被 JavaScript 引擎解释为：

```js
var a; // 声明被提升到作用域顶部
console.log(a); // undefined
a = 5; // 赋值仍在原地
console.log(a); // 5
```

let 和 const 的暂时性死区（TDZ）

```js
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 10;

console.log(c); // ReferenceError: Cannot access 'c' before initialization
const c = 15;
```

## 函数提升

函数声明

```js
sayHello(); // "Hello!"，可以正常调用

function sayHello() {
    console.log("Hello!");
}
```
函数表达式

```js
// 函数表达式不会提升
sayHi(); // TypeError: sayHi is not a function

var sayHi = function() {
    console.log("Hi!");
};
```

## 提升的优先级

函数声明优先于变量声明

```js
console.log(typeof myFunc); // "function"

var myFunc = "I'm a variable";
function myFunc() {
    return "I'm a function";
}

console.log(typeof myFunc); // "string"
```

多个同名的函数声明，后面的会覆盖前面的

```js
test(); // "Second"

function test() {
    console.log("First");
}

function test() {
    console.log("Second");
}
```

## 类声明的提升

```js
// 类声明也会提升，但在声明前访问会报错
const p = new Person(); // ReferenceError

class Person {
    constructor() {
        this.name = "John";
    }
}
```

## 最佳实践建议

1. 始终先声明后使用
2. 使用 let 和 const 代替 var