# 作用域

JavaScript 作用域（Scope）决定了变量、函数和对象的**可访问性**。作用域就像一个“盒子”，规定了代码在哪里可用，在哪里不可用。

## 词法作用域

在JavaScript中，词法作用域（也称为静态作用域）是指作用域在代码编写时（或者说在词法分析时）就已经确定，而不是在运行时确定。这意味着函数的作用域基于它被**声明的位置**，而不是它被调用的位置。

具体来说，JavaScript 中的作用域是由函数声明和块级作用域（使用 let 和 const）来决定的。当代码执行时，它会从当前作用域开始查找变量，如果找不到，就会逐级向上到父作用域查找，直到全局作用域。这种作用域的嵌套关系在代码写好的时候就已经确定了。

对比动态作用域，动态作用域是在**运行时**根据调用链来确定的。JavaScript 不具有动态作用域，但是 JavaScript 中的 this 机制在某些方面类似于动态作用域，但注意 this 并不是作用域，它是执行上下文的一部分。

## 作用域的类型

### 1. 全局作用域

在函数外部或代码块外部声明的变量，可以在任何地方访问。

```js
var globalVar = "我是全局变量";

function show() {
    console.log(globalVar); // 可以访问
}

show(); // "我是全局变量"
console.log(globalVar); // "我是全局变量"
```

### 2. 函数作用域

使用 **var** 声明的变量具有函数作用域（只能在函数内部访问）。

```js
function myFunction() {
    var functionVar = "我在函数内部";
    console.log(functionVar); // 可以访问
}

myFunction(); // "我在函数内部"
console.log(functionVar); // 报错：functionVar is not defined
```

> 在函数内部使用let或const声明的变量属于块级作用域

### 3. 块级作用域（ES6+）

使用 let 和 const 声明的变量具有块级作用域（在 {} 内有效）。

```js
if (true) {
    let blockVar = "我在块内";
    const constVar = "我也是块内";
    console.log(blockVar); // 可以访问
}
console.log(blockVar); // 报错：blockVar is not defined
```

## 作用域链

当访问一个变量时，JavaScript 引擎会从当前作用域开始查找，如果找不到，就向上一级作用域查找，直到全局作用域。

```js
var global = "全局";

function outer() {
    var outerVar = "外部";
    
    function inner() {
        var innerVar = "内部";
        console.log(innerVar); // "内部"（当前作用域）
        console.log(outerVar); // "外部"（父作用域）
        console.log(global); // "全局"（全局作用域）
    }
    
    inner();
}

outer();
```