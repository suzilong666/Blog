# 相等性比较

## 抽象相等比较（==）

也称为松散相等，当类型不同时，在比较前会进行类型转换。

### 字符串和数字之间的相等比较

字符串类型转换为数字类型

```js
5 == '5';          // true (字符串转数字)
5 == '6';          // false
```

### 布尔类型和其他类型的相等比较

布尔类型转换为数字类型

```js
'42' == true // false
```
true 是布尔类型，转换为数字类型 1，'42' == 1 ，此时类型还是不同，'42' 转换为数字 42，42 == 1 ，因此它们不相等。

### null 和 undefined 之间的相等比较

在 == 中 null 和 undefined 相等（它们也与自身相等），**除此之外其他值都不和它们两个相等**。

```js
var a = null;
var b;

a == b; // true
a == null; // true
b == null; // true

a == false; // false
b == false; // false
a == ''; // false
b == ''; // false
a == 0; // false
b == 0; // false
```

### 对象 和 基本类型 之间的相等比较

将对象转换为基本类型再比较。

**对象转换为基本类型原理**

```
对象 == 基本类型
    ↓
检查对象是否有 [Symbol.toPrimitive] 方法？ (ES6+)
    ↓ 没有或不是函数
调用 valueOf()
    ↓ 返回原始值？
    ├─ 是 → 使用该原始值比较
    ↓ 否
调用 toString()
    ↓ 返回原始值？
    ├─ 是 → 使用该原始值比较
    ↓ 否
抛出 TypeError
```

#### 特殊情况

- NaN 不等于 NaN
- +0 不等于 -0


## 严格相等比较（===）

也称为严格相等，不进行类型转换，要求类型相同且值相等。

#### 规则

- 如果类型不同，返回false。
- 如果类型相同，则比较值：
  - 对于基本类型，直接比较值是否相同。
  - 对于引用类型，比较它们是否指向同一个内存地址（即同一个对象）。

```js
5 === 5;           // true
5 === '5';         // false (类型不同)
NaN === NaN;       // false
0 === -0;          // true
```

## 同值零比较（Object.is）

ES6新增的方法，与严格相等类似，但对待NaN和+0、-0不同。

```js
Object.is(NaN, NaN);   // true
Object.is(+0, -0);     // false
Object.is(5, '5');     // false (同===，类型不同)
```

## 最佳实践

- 绝大多数情况下，应使用严格相等 ===/!==，可避免隐式转换带来的意外结果。
- 避免使用抽象相等 ==/!=，除非你明确理解其转换规则并需要简写（如 val == null 可同时检查 null 和 undefined）。
- **Object.is() 主要用于需要精确识别 NaN 或区分 +0 和 -0 的特殊场景（如数学计算、库开发）。

## 注意

常见的误区：“==检查值是否相等，===检查值和类型是否相等”，这个解释是错误的。

正确的解释是：“==允许在相等比较中进行强制类型转换，而===不允许”