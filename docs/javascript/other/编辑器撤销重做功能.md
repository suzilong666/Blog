# 编辑器撤销重做功能

**核心思想：**记录与回溯

无论哪种方案，撤销/重做的本质都是：记录下用户的每一步操作，并在需要时，能够沿着记录反向（撤销）或正向（重做）执行，以恢复编辑器的状态。

下面我们解释几种实现撤销重做功能的思路：

## 命令模式（操作式记录）

这是最经典、最符合直觉的思路。

1. **核心概念：**将用户的每一次编辑（如输入文字、删除、格式化）都封装成一个独立的“命令”对象。

2. **关键属性：**每个命令对象都必须包含两个关键方法：
   - execute：执行这个命令，完成操作（如插入文本）。
   - undo：执行这个命令的“逆操作”（如删除刚才插入的文本），让状态回到执行前。

3. **两个栈：**维护两个栈结构（先进后出）：
   - undoStack（撤销栈）：按顺序存放所有已执行成功的命令。
   - redoStack（重做栈）：存放被撤销的命令。

4. **工作流程：**
   - 用户操作时：创建一个对应命令，执行它，然后将这个命令压入 undoStack，同时清空 redoStack（因为新的操作分支开始了）。
   - 撤销时：从 undoStack 顶部弹出一个命令，执行它的 undo 方法，然后将这个命令压入 redoStack。
   - 重做时：从 redoStack 顶部弹出一个命令，执行它的 execute 方法，然后将这个命令压回 undoStack。

**优点：**

- 逻辑清晰：每个操作独立管理。
- 功能强大：易于实现复杂操作（如选区变化、样式更改），因为逆操作可以自由定义。
- 内存效率：通常只存储变化的增量信息，而不是整个文档。

**缺点：**

- 需要为每一种操作（输入、删除、加粗、粘贴等）都设计对应的命令类，前期工作量大。
- 命令之间的依赖关系需要仔细处理。

## 快照模式（状态式记录）

这种思路更直接：保存编辑器在**不同时间点的完整状态**。

1. 核心概念：在每次用户操作后（或操作前），将当前编辑器所有内容（文本、样式、光标位置等）深拷贝一份，作为一个“快照”保存起来。
2. 一个状态数组 + 一个指针：
    - 用一个数组按顺序存放所有历史快照。
    - 用一个“指针”指向当前生效的快照在数组中的位置。
3. 工作流程：
    - 用户操作时：编辑器状态改变。将新状态生成快照，追加到指针所指位置之后，然后将指针移动到新快照。如果指针不在末尾，则需要丢弃它之后的所有旧快照（因为产生了新的时间线分支）。
    - 撤销时：将指针向前移动一位，然后将编辑器的完整状态替换为指针指向的那个旧快照。
    - 重做时：将指针向后移动一位，然后将编辑器状态替换为指针指向的那个新快照。

**优点：**

- 实现简单：逻辑非常直接，不需要为每个操作定义逆操作。
- 状态稳定：每次恢复的都是一个确定、完整的快照，不存在因命令执行顺序错误导致状态错乱的风险。

**缺点：**

- 内存占用巨大：每次保存的都是完整状态，对于大型文档（如图文混排、富文本）非常消耗内存。
- 性能开销：生成和恢复完整快照（尤其是涉及DOM或复杂对象）可能比较慢。

**优化方向：**通常会对快照进行压缩（如使用**差异算法**，只存储与上一个快照不同的部分），或者限制历史记录条数（如只保留最近50次操作）。

## 混合模式（结合思路一与思路二）

这是实践中常用的折中方案，兼具两者优点。

1. **核心概念**：对于高频、细粒度的操作（如连续输入字符），使用命令模式记录操作序列；在特定时机（如用户停顿、切换操作类型、主动保存时），创建一个完整快照作为“检查点”。
2. **工作流程：**
    - 用户连续输入时，记录一串“插入字符”的命令。
    - 用户切换到格式化操作时，系统生成一个当前状态的快照作为“里程碑”。
    - 当需要撤销到很久之前的操作时，系统会先跳转到最近的一个快照，然后重播/逆播从那个快照到目标状态之间的所有命令。

**优点：**

- 在内存消耗和实现复杂度之间取得了良好平衡。
- 既能高效处理高频操作，又能快速进行长距离的历史跳转。


## 总结与选择建议

- 如果是简单文本编辑器或状态管理：快照模式思路简单，易于实现。
- 如果是功能复杂的富文本编辑器或图形编辑器：命令模式是首选，因为它能精确控制每一个原子操作的逆向过程。
- 如果是追求性能和生产级的应用：混合模式是最佳实践，它结合了快照的“稳定性”和命令的“高效性”。

最终，选择哪种思路取决于您的应用场景、性能要求以及对“撤销”这个行为精确度的期望。

