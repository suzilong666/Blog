# 深拷贝与浅拷贝

在JavaScript中，深拷贝和浅拷贝是两种不同的复制对象的方式。

## 浅拷贝

只复制对象的第一层属性，如果属性是基本类型，则直接复制值；如果属性是引用类型，则复制其引用（即内存地址）。

因此，对于引用类型的属性，原对象和拷贝对象会共享同一块内存，修改其中一个会影响另一个。

#### 实现浅拷贝的方法：

- 使用扩展运算符（...）
- Object.assign()
- 手动遍历对象并复制属性（只复制第一层）

## 深拷贝

递归复制对象的所有层级，包括引用类型的属性，直到所有属性都是基本类型为止。

这样，原对象和拷贝对象完全独立，修改其中一个不会影响另一个。

#### 实现深拷贝的方法：

- 使用JSON.parse(JSON.stringify(object))。

    **注意：**这种方法有局限性，会忽略undefined、函数、Symbol等，同时不能处理循环引用。

- 使用递归函数，遍历对象的每个属性，如果是引用类型则递归复制。
- 使用第三方库，如lodash的_.cloneDeep()方法。

#### 深拷贝函数

```js
function deepClone(obj, hash = new WeakMap()) {
  // 基本类型和函数直接返回
  if (obj === null || typeof obj !== 'object') return obj;
  if (typeof obj === 'function') return obj;
  
  // 避免循环引用
  if (hash.has(obj)) return hash.get(obj);
  
  // 特殊对象类型处理
  const Constructor = obj.constructor;
  
  switch (Constructor) {
    case RegExp:
      return new RegExp(obj);
    case Date:
      return new Date(obj.getTime());
    case Set:
      const set = new Set();
      hash.set(obj, set);
      obj.forEach(value => set.add(deepClone(value, hash)));
      return set;
    case Map:
      const map = new Map();
      hash.set(obj, map);
      obj.forEach((value, key) => map.set(key, deepClone(value, hash)));
      return map;
    case ArrayBuffer:
      return obj.slice(0);
    case Int8Array:
    case Uint8Array:
    case Int16Array:
    case Uint16Array:
    case Int32Array:
    case Uint32Array:
    case Float32Array:
    case Float64Array:
      return new Constructor(obj);
  }
  
  // 普通对象或数组
  const cloneObj = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  hash.set(obj, cloneObj);
  
  // 复制Symbol属性
  const symKeys = Object.getOwnPropertySymbols(obj);
  const allKeys = [...Object.keys(obj), ...symKeys];
  
  for (const key of allKeys) {
    cloneObj[key] = deepClone(obj[key], hash);
  }
  
  return cloneObj;
}
```