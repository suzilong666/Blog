import{_ as i,o as t,c as r,ah as a}from"./chunks/framework.Dzv1qGE5.js";const g=JSON.parse('{"title":"编辑器撤销重做功能","description":"","frontmatter":{},"headers":[{"level":2,"title":"命令模式（操作式记录）","slug":"命令模式-操作式记录","link":"#命令模式-操作式记录","children":[]},{"level":2,"title":"快照模式（状态式记录）","slug":"快照模式-状态式记录","link":"#快照模式-状态式记录","children":[]},{"level":2,"title":"混合模式（结合思路一与思路二）","slug":"混合模式-结合思路一与思路二","link":"#混合模式-结合思路一与思路二","children":[]},{"level":2,"title":"总结与选择建议","slug":"总结与选择建议","link":"#总结与选择建议","children":[]}],"relativePath":"javascript/other/编辑器撤销重做功能.md","filePath":"javascript/other/编辑器撤销重做功能.md"}'),e={name:"javascript/other/编辑器撤销重做功能.md"};function o(n,l,s,p,u,c){return t(),r("div",null,[...l[0]||(l[0]=[a('<h1 id="编辑器撤销重做功能" tabindex="-1">编辑器撤销重做功能 <a class="header-anchor" href="#编辑器撤销重做功能" aria-label="Permalink to “编辑器撤销重做功能”">​</a></h1><p><strong>核心思想：</strong>记录与回溯</p><p>无论哪种方案，撤销/重做的本质都是：记录下用户的每一步操作，并在需要时，能够沿着记录反向（撤销）或正向（重做）执行，以恢复编辑器的状态。</p><p>下面我们解释几种实现撤销重做功能的思路：</p><h2 id="命令模式-操作式记录" tabindex="-1">命令模式（操作式记录） <a class="header-anchor" href="#命令模式-操作式记录" aria-label="Permalink to “命令模式（操作式记录）”">​</a></h2><p>这是最经典、最符合直觉的思路。</p><ol><li><p><strong>核心概念：</strong>将用户的每一次编辑（如输入文字、删除、格式化）都封装成一个独立的“命令”对象。</p></li><li><p><strong>关键属性：</strong>每个命令对象都必须包含两个关键方法：</p><ul><li>execute：执行这个命令，完成操作（如插入文本）。</li><li>undo：执行这个命令的“逆操作”（如删除刚才插入的文本），让状态回到执行前。</li></ul></li><li><p><strong>两个栈：</strong>维护两个栈结构（先进后出）：</p><ul><li>undoStack（撤销栈）：按顺序存放所有已执行成功的命令。</li><li>redoStack（重做栈）：存放被撤销的命令。</li></ul></li><li><p><strong>工作流程：</strong></p><ul><li>用户操作时：创建一个对应命令，执行它，然后将这个命令压入 undoStack，同时清空 redoStack（因为新的操作分支开始了）。</li><li>撤销时：从 undoStack 顶部弹出一个命令，执行它的 undo 方法，然后将这个命令压入 redoStack。</li><li>重做时：从 redoStack 顶部弹出一个命令，执行它的 execute 方法，然后将这个命令压回 undoStack。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>逻辑清晰：每个操作独立管理。</li><li>功能强大：易于实现复杂操作（如选区变化、样式更改），因为逆操作可以自由定义。</li><li>内存效率：通常只存储变化的增量信息，而不是整个文档。</li></ul><p><strong>缺点：</strong></p><ul><li>需要为每一种操作（输入、删除、加粗、粘贴等）都设计对应的命令类，前期工作量大。</li><li>命令之间的依赖关系需要仔细处理。</li></ul><h2 id="快照模式-状态式记录" tabindex="-1">快照模式（状态式记录） <a class="header-anchor" href="#快照模式-状态式记录" aria-label="Permalink to “快照模式（状态式记录）”">​</a></h2><p>这种思路更直接：保存编辑器在<strong>不同时间点的完整状态</strong>。</p><ol><li>核心概念：在每次用户操作后（或操作前），将当前编辑器所有内容（文本、样式、光标位置等）深拷贝一份，作为一个“快照”保存起来。</li><li>一个状态数组 + 一个指针： <ul><li>用一个数组按顺序存放所有历史快照。</li><li>用一个“指针”指向当前生效的快照在数组中的位置。</li></ul></li><li>工作流程： <ul><li>用户操作时：编辑器状态改变。将新状态生成快照，追加到指针所指位置之后，然后将指针移动到新快照。如果指针不在末尾，则需要丢弃它之后的所有旧快照（因为产生了新的时间线分支）。</li><li>撤销时：将指针向前移动一位，然后将编辑器的完整状态替换为指针指向的那个旧快照。</li><li>重做时：将指针向后移动一位，然后将编辑器状态替换为指针指向的那个新快照。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>实现简单：逻辑非常直接，不需要为每个操作定义逆操作。</li><li>状态稳定：每次恢复的都是一个确定、完整的快照，不存在因命令执行顺序错误导致状态错乱的风险。</li></ul><p><strong>缺点：</strong></p><ul><li>内存占用巨大：每次保存的都是完整状态，对于大型文档（如图文混排、富文本）非常消耗内存。</li><li>性能开销：生成和恢复完整快照（尤其是涉及DOM或复杂对象）可能比较慢。</li></ul><p><strong>优化方向：</strong>通常会对快照进行压缩（如使用<strong>差异算法</strong>，只存储与上一个快照不同的部分），或者限制历史记录条数（如只保留最近50次操作）。</p><h2 id="混合模式-结合思路一与思路二" tabindex="-1">混合模式（结合思路一与思路二） <a class="header-anchor" href="#混合模式-结合思路一与思路二" aria-label="Permalink to “混合模式（结合思路一与思路二）”">​</a></h2><p>这是实践中常用的折中方案，兼具两者优点。</p><ol><li><strong>核心概念</strong>：对于高频、细粒度的操作（如连续输入字符），使用命令模式记录操作序列；在特定时机（如用户停顿、切换操作类型、主动保存时），创建一个完整快照作为“检查点”。</li><li><strong>工作流程：</strong><ul><li>用户连续输入时，记录一串“插入字符”的命令。</li><li>用户切换到格式化操作时，系统生成一个当前状态的快照作为“里程碑”。</li><li>当需要撤销到很久之前的操作时，系统会先跳转到最近的一个快照，然后重播/逆播从那个快照到目标状态之间的所有命令。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>在内存消耗和实现复杂度之间取得了良好平衡。</li><li>既能高效处理高频操作，又能快速进行长距离的历史跳转。</li></ul><h2 id="总结与选择建议" tabindex="-1">总结与选择建议 <a class="header-anchor" href="#总结与选择建议" aria-label="Permalink to “总结与选择建议”">​</a></h2><ul><li>如果是简单文本编辑器或状态管理：快照模式思路简单，易于实现。</li><li>如果是功能复杂的富文本编辑器或图形编辑器：命令模式是首选，因为它能精确控制每一个原子操作的逆向过程。</li><li>如果是追求性能和生产级的应用：混合模式是最佳实践，它结合了快照的“稳定性”和命令的“高效性”。</li></ul><p>最终，选择哪种思路取决于您的应用场景、性能要求以及对“撤销”这个行为精确度的期望。</p>',27)])])}const h=i(e,[["render",o]]);export{g as __pageData,h as default};
